#include "defs.h"
//#include "keys2a.h"
#include "Reader.h"
#include "Drawings.h"
#include "PairwiseInfoWithPoints.h"
#include "ViewInfoWithPoints.h"
#include "ReadBundlerMatchGraph.h"
#include "EstimatePairwiseInfo.h"
#include "EvaluateTripletsForRotationLoop.h"
#include "ComputeOptimizationCosts.h"
#include "Util.h"
#include "FilterViewGraph.h"
/*
#include "EstimateSecondaryGeometry.h"
*/
#include <theia/theia.h>

void CreateViewingGraph(vector<ViewInfoWithPoints>& viewInfo,
    vector<PairwiseInfoWithPoints>& twoviewInfo,
    theia::ViewGraph* viewingGraph) {

  for(int i=0; i < twoviewInfo.size(); i++) {

    PairwiseInfoWithPoints& pairwise = twoviewInfo[i];

    int img1 = pairwise.image1;
    int img2 = pairwise.image2;

    if(pairwise.viewGraphEdgeIntialized) {
      (*viewingGraph).AddEdge(pairwise.image1, pairwise.image2, pairwise.primaryMotion);
    }

  }
}


void VisualizeTripletsWithScores(vector<ViewInfoWithPoints>& viewInfo,
    vector<PairwiseInfoWithPoints>& twoviewInfo) {

  printf("\nHere.....");
  fflush(stdout);
  for(int i=0; i < twoviewInfo.size(); i++) {
    printf("\nPair %d", i);
    PairwiseInfoWithPoints& pairwise = twoviewInfo[i];
    if(!pairwise.viewGraphEdgeIntialized) {
      continue;
    }

    vector< cv::Point2f > matchPointSet11, matchPointSet12;
    CreatePointSetsFromIndexedMatches( pairwise.primaryVerifiedMatches, 
        viewInfo[pairwise.image1].keysWithDesc.keypoints,
        viewInfo[pairwise.image2].keysWithDesc.keypoints,
        matchPointSet11, matchPointSet12);

    printf("\nTotal %d triplets", pairwise.tripletErrorVec.size());
    fflush(stdout);

    for(int j=0; j < pairwise.tripletErrorVec.size(); j++) {
      printf("\nScore %f", pairwise.tripletErrorVec[j]);

      fflush(stdout);
      int pairIndex2 = pairwise.connectedTripletEdges[j].first;
      int pairIndex3 = pairwise.connectedTripletEdges[j].second;

      PairwiseInfoWithPoints& pairwise2 = twoviewInfo[pairIndex2];
      PairwiseInfoWithPoints& pairwise3 = twoviewInfo[pairIndex3];

      string firstImage = viewInfo[pairwise.image1].fullImageName;
      string secondImage = viewInfo[pairwise.image2].fullImageName;
      string thirdImage;

      vector< cv::Point2f > matchPointSet21, matchPointSet22;
      vector< cv::Point2f > matchPointSet31, matchPointSet32;
      CreatePointSetsFromIndexedMatches( pairwise2.primaryVerifiedMatches, 
          viewInfo[pairwise2.image1].keysWithDesc.keypoints,
          viewInfo[pairwise2.image2].keysWithDesc.keypoints,
          matchPointSet21, matchPointSet22);

      CreatePointSetsFromIndexedMatches( pairwise3.primaryVerifiedMatches, 
          viewInfo[pairwise3.image1].keysWithDesc.keypoints,
          viewInfo[pairwise3.image2].keysWithDesc.keypoints,
          matchPointSet31, matchPointSet32);

      DrawOutliers(viewInfo[pairwise.image1].fullImageName, 
          matchPointSet11, matchPointSet11,"Pair1 Image1");
      DrawOutliers(viewInfo[pairwise.image2].fullImageName, 
          matchPointSet12, matchPointSet12,"Pair1 Image2");

      DrawOutliers(viewInfo[pairwise2.image1].fullImageName, 
          matchPointSet21, matchPointSet21,"Pair2 Image1");
      DrawOutliers(viewInfo[pairwise2.image2].fullImageName, 
          matchPointSet22, matchPointSet22,"Pair2 Image2");

      DrawOutliers(viewInfo[pairwise3.image1].fullImageName, 
          matchPointSet31, matchPointSet31,"Pair3 Image1");
      DrawOutliers(viewInfo[pairwise3.image2].fullImageName, 
          matchPointSet32, matchPointSet32,"Pair3 Image2");

      cv::waitKey();
    }
  }
}

void VisualizePairsWithScores(vector<ViewInfoWithPoints>& viewInfo,
    vector<PairwiseInfoWithPoints>& twoviewInfo) {

  for(int i=0; i < twoviewInfo.size(); i++) {
    printf("\n%Pair %d", i);
    PairwiseInfoWithPoints& pairwise = twoviewInfo[i];
    if(!pairwise.viewGraphEdgeIntialized) {
      continue;
    }

    printf("\nPrimary matches");
    vector< cv::Point2f > matchPointSet1, matchPointSet2;
    CreatePointSetsFromIndexedMatches( pairwise.primaryVerifiedMatches, 
        viewInfo[pairwise.image1].keysWithDesc.keypoints,
        viewInfo[pairwise.image2].keysWithDesc.keypoints,
        matchPointSet1, matchPointSet2);

    printf("\nSecondary matches");

    vector< cv::Point2f > matchPointSet21, matchPointSet22;
    CreatePointSetsFromIndexedMatches( pairwise.secondaryVerifiedMatches, 
        viewInfo[pairwise.image1].keysWithDesc.keypoints,
        viewInfo[pairwise.image2].keysWithDesc.keypoints,
        matchPointSet21, matchPointSet22);

    DrawOutliers(viewInfo[pairwise.image1].fullImageName, 
        matchPointSet1, matchPointSet21,"Image1");
    DrawOutliers(viewInfo[pairwise.image2].fullImageName, 
        matchPointSet2, matchPointSet22,"Image2");

    vector<string> scoreNames(8);
    scoreNames[0] = "Ratio1";
    scoreNames[1] = "Ratio2";
    scoreNames[2] = "Has2Gm";
    scoreNames[3] = "MerMot";
    scoreNames[4] = "Angulr";
    scoreNames[5] = "Positn"; 
    scoreNames[6] = "hasHom";
    scoreNames[7] = "Homogr";

    vector<double> scoreValue(8);
    scoreValue[0] = pairwise.scores.ratio1;
    scoreValue[1] = pairwise.scores.ratio2;
    scoreValue[2] = (double)(pairwise.hasTwoGeometries);
    scoreValue[3] = (double)(pairwise.mergeMotions);
    scoreValue[4] = pairwise.scores.angularDiff;
    scoreValue[5] = pairwise.scores.positionDiff;
    scoreValue[6] = (double)(pairwise.homographyFound);
    scoreValue[7] = pairwise.scores.homographyScore;

    DrawScoreBoard( scoreNames, scoreValue );
    cv::waitKey(0);


  }
}

int main(int argc, char* argv[]) {
  google::InitGoogleLogging(argv[0]);

  string baseDirectory = string(argv[1]);
  string solFileName = string(argv[2]);
  string normOptFile = baseDirectory + "/norm_options.txt";
  int totalFlow = atoi(argv[3]);
  int numViews = atoi(argv[4]);
  int numPairs = atoi(argv[5]);

  vector< ViewInfoWithPoints > views(numViews);
  vector< PairwiseInfoWithPoints > twoViewInfoVec(numPairs);

  for(int i=0; i < views.size(); i++) {
    ViewInfoWithPoints& currView =  views[i];
    stringstream ss;
    ss << baseDirectory << "/binary_tmp/view-i" << i <<".bin";
    ReadViewInfoFromDisk( ss.str(), &currView );
  }

  std::unordered_map<theia::ViewIdPair, int> edge2indexMap;
  for(int i=0; i < twoViewInfoVec.size(); i++) { 
    PairwiseInfoWithPoints& pair = twoViewInfoVec[i];
    stringstream ss;
    ss << baseDirectory << "/binary_tmp/pair-" << i <<".bin";
    ReadPairwiseInfoFromDisk( ss.str(), &pair );

    theia::ViewIdPair view_pair(pair.image1, pair.image2);
    edge2indexMap.insert(make_pair(view_pair, i));
  }



  theia::ViewGraph viewingGraph;
  bool s4 = ComputeTwoGeometryScores( views, twoViewInfoVec ); 
  printf("\nRead two geometry scores");
  fflush(stdout);

  bool s5 = ComputeOverlapRatioScores( views, twoViewInfoVec ); 
  printf("\nRead ratio scores");
  fflush(stdout);
  
  bool s6 = ComputeHomographyScores( views, twoViewInfoVec ); 
  printf("\nComputed homography scores");
  fflush(stdout);

  bool s7 = ComputeContextScore( views, twoViewInfoVec );
  printf("\nComputed context scores");
  fflush(stdout);
  
  CreateViewingGraph( views, twoViewInfoVec, &viewingGraph ); 
  EvaluateTripletsForRotationLoop(&viewingGraph, edge2indexMap, twoViewInfoVec );
  printf("\nComputed triplet scores");
  fflush(stdout);
  //VisualizePairsWithScores( views, twoViewInfoVec );
  //VisualizeTripletsWithScores( views, twoViewInfoVec );

  printf("\nDone estimating triplet loops");
  fflush(stdout);

  ScoresStruct scoreStr;
  bool s0 = ReadNormOptFile( normOptFile , scoreStr ); 
  PopulateScoresStructure( twoViewInfoVec, views , scoreStr, baseDirectory); //Written as raw scores 
  ComputeCostsFromScores( scoreStr, views, twoViewInfoVec, baseDirectory); //Write normalized scores

  ViewGraphFilter filter;
  filter.pairsInfoPtr = &(twoViewInfoVec);
  filter.viewsPtr = &(views);
  filter.edge2indexMap = &(edge2indexMap);

  filter.constructNetworkFlowProblem(totalFlow);
  filter.solveNetworkFlowProblem();
  filter.writeSolution(baseDirectory + "/" + solFileName);

  exit(-1);

/*



  const auto& all_edges = viewingGraph.GetAllEdges();
  theia::ReconstructionBuilderOptions options;
  options.reconstruction_estimator_options.reconstruction_estimator_type = 
    theia::ReconstructionEstimatorType::INCREMENTAL;

  theia::ReconstructionBuilder reconstruction_builder(options);

  for(int i=0; i < base_views.size(); i++) {
    reconstruction_builder.AddImageWithCameraIntrinsicsPrior(
        base_views[i].Name(), views[i].CameraIntrinsicsPrior(), 
        theia::kInvalidCameraIntrinsicsGroupId);
  }

  printf("\nAdded all images");
  fflush(stdout);

  // Create an MST reconstruction.
  vetcor<int> selectedPairsIndices;
  for(int i=0; i < filter.networkFlowSol.size(); i++) {
    if(filter.nwSol2vgIdx[i].first == "pair") {
    if(filter.networkFlowSol[i] > 0.0f) {
    filter.selectedPairIndices.push_back( nwSol2vgIdx[i].second );
    }
    } 
  }

  for (int i=0; i < filter.selectedPairIndices.size(); i++) {
    int pairIndex = filter.selectedPairIndices[i];
    PairwiseInfoWithPoints pairwise = twoViewInfoVec[pairIndex];
    //DrawPairsWithPoints(views[pairwise.image1].fullImageName, views[pairwise.image2].fullImageName, pairwise.verifiedFeatures1, pairwise.verifiedFeatures2, jointScore[pairIndex], outputFile.str());

    theia::ImagePairMatch imgPair;
    imgPair.image1 = base_views[pairwise.image1].Name();
    imgPair.image2 = base_views[pairwise.image2].Name();

    imgPair.twoview_info = pairwise;
    imgPair.correspondences.resize( pairwise.verifiedFeatures1.size() );

    for(int i=0; i < imgPair.correspondences.size(); i++) {
      imgPair.correspondences[i].feature1 = theia::Feature(pairwise.verifiedFeatures1[i].x, pairwise.verifiedFeatures1[i].y);
      imgPair.correspondences[i].feature2 = theia::Feature(pairwise.verifiedFeatures2[i].x, pairwise.verifiedFeatures2[i].y);
    }

    reconstruction_builder.AddTwoViewMatch( base_views[pairwise.image1].Name(), base_views[pairwise.image2].Name(), imgPair );

  }
  printf("\nAdded all pairs");
  fflush(stdout);


  std::vector<theia::Reconstruction*> reconstructions;
  bool status = reconstruction_builder.BuildReconstruction(&reconstructions);

  if(!status) {
    cout << "\nFailed to create reconstruction";
    fflush(stdout);
    exit(-1);

  }

  string output_prefix = "result_reconstruction";
  for (int i = 0; i < reconstructions.size(); i++) {
    const std::string output_file =
      theia::StringPrintf("%s-%d", output_prefix.c_str(), i);
    cout << "Writing reconstruction " << i << " to " << output_file;
    if(!theia::WriteReconstruction(*reconstructions[i], output_file))
      cout << "Could not write reconstruction to file.";
  }

  fflush(stdout);
  */

  return 0;
}
