#include "defs.h"
//#include "keys2a.h"
#include "Reader.h"
//#include "Drawings.h"
#include "PairwiseInfoWithPoints.h"
#include "ViewInfoWithPoints.h"
/*
#include "EvaluateTripletsForRotationLoop.h"
#include "EstimateViewingGraph.h"
#include "EstimateSecondaryGeometry.h"
#include "ReadBundlerMatchGraph.h"
#include "Util.h"
#include "FilterViewGraph.h"
*/
#include <theia/theia.h>

struct NormParams {
  NormParams(): initialized(false) {}

  bool initialized;
  bool minMax01;

  double k1;
  double k2;
  double k3;
  double k4;
  double k5;
  double k6;

  double high;
  double low;
};


enum ScoreType{
  NCONN = 0,
  FCONN,
  DSJT,
  OVSUM,
  OVMUL,
  HG,
  CTXCS,
  CTXHM,
  CTXCHI2,
  TRIPLET,
  MMOTION,
  LOOP,
  NUM_SCORES //Always keep this last, as we use this enum for indexing
};

class ScoresStruct {

  public:
  map<int, int> scoreIdx2Node;
  map<int, int> scoreIdx2Edge;


  NormParams params[NUM_SCORES];
  vector< vector< double > > inScore;
  vector< vector< double > > outScore;

  /*
  vector< double > nodeConnFitness;
  vector< double > featConnFitness;
  vector< double > disjointFitness;

  vector< double > overlapSum;
  vector< double > overlapMult;
  vector< double > homographyFitness;
  vector< double > contextScoreCosine;
  vector< double > contextScoreHamming;
  vector< double > contextScoreChiSqr;

  vector< double > tripletConnFitness;
  vector< double > multiMotionFitness;
  vector< double > loopFitness; 
  */

  ScoresStruct();

  void normalizeAllScores();
  void normalize( vector<double>& input, vector<double>& output, NormParams& param);  

//  double k1, double k2, double k3, double k4, double k5, double k6, 
//      double low, double high);

};


ScoresStruct::ScoresStruct() {

  inScore.resize(NUM_SCORES);
  outScore.resize(NUM_SCORES);

}


void ScoresStruct::normalizeAllScores() {
  for(int i=0; i < NUM_SCORES; i++) {
    if(params[i].initialized && inScore[i].size()) {
      normalize(inScore[i], outScore[i], params[i]);  
    }
  } 
}


void ScoresStruct::normalize( vector<double>& input, 
    vector<double>& output, NormParams& param) {
    
//    double k1, double k2, 
//    double k3, double k4, double k5, double k6, 
//    double low, double high) {

  double minInp = *std::min_element(input.begin(), input.end());
  double maxInp = *std::max_element(input.begin(), input.end());

  vector<double> tmp(input.size());
  if(param.minMax01) {
    for(int i=0; i < tmp.size(); i++) {
      tmp[i] = (input[i] - minInp)/(maxInp - minInp);
    }
  } else{
    tmp = input;
  }

  output.resize(input.size());
  for(int i=0; i < tmp.size(); i++) {
    if(tmp[i] >= param.k1 && tmp[i] < param.k2) {
       output[i] = param.low;
    }

    if(tmp[i] >= param.k2 && tmp[i] < param.k3) {
      double m = (param.high - param.low)/ (param.k3 - param.k2);
      double c = (param.low*param.k3 - param.high*param.k2)/(param.k3 - param.k2);
      output[i] = m * tmp[i] + c; 
    }

    if(tmp[i] >=param.k3 && tmp[i] < param.k4) {
      output[i] = param.high;
    }

    if(tmp[i] >=param.k4 && tmp[i] < param.k5) {
      double m = (param.low - param.high)/(param.k5 - param.k4); 
      double c = (param.k5*param.high - param.k4*param.low)/(param.k5 - param.k4);
      output[i] = m* tmp[i] + c; 
    }

    if(tmp[i] >= param.k5 && tmp[i] <= param.k6) {
      output[i] = param.low; 
    }
  }
}

void EstimateConnectivityScore( vector<TwoViewInfoWithPoints>& twoviewInfo, 
    vector<ViewInfoWithPoints>& views) {

  int numImages = views.size();
  vector< vector < bool > > connectionMat( numImages ); 
  int maxDegree = 0;
  for(int i=0; i < numImages; i++) {
    connectionMat[i].resize( numImages );
    for(int j=0; j < connectionMat[i].size(); j++) {
      connectionMat[i][j] = false;
    }
    if(views[i].degree > maxDegree) {
      maxDegree = views[i].degree;
    }
  }

  vector< vector< int > > connectionLists(numImages);

  for(int i=0; i < twoviewInfo.size(); i++) {
    int img1 = twoviewInfo[i].image1;
    int img2 = twoviewInfo[i].image2;

    connectionMat[img1][img2] = true;
    connectionMat[img2][img1] = true;

    connectionLists[img1].push_back(img2);
    connectionLists[img2].push_back(img1);
  }

  for(int i=0; i < views.size(); i++) {
    int groupConnectivity = 0;
    for(int j=0; j < connectionLists[i].size(); j++) {
      int img1 = connectionLists[i][j];
      for(int k=0; k < j; k++) {
        int img2 = connectionLists[i][k];

        if(connectionMat[img1][img2]) {
          groupConnectivity++;
        }
      }
    }

    double N = (double)(connectionLists[i].size());
    views[i].disjointFitness = (double) (groupConnectivity) / (N * (N - 1) / 2); 
    views[i].connectivityFitness = (double)(views[i].degree) / (maxDegree * 1.0f);
    views[i].featureFitness = (double)(views[i].numMatchedFeatures)/ (views[i].numFeatures);
  }

}


void ComputeFeatureDistribution(set<int>& featIndices, vector<float> weights, vector< set<FeatureId> >& feat2ImgMap, vector<float>& featHist) {
  set<int>::iterator itr = featIndices.begin();
  for(int count = 0; itr != featIndices.end(); itr++, count++) {
    float weight = weights[count];
    int featIdx = *itr;
    set<FeatureId>& imgMap = feat2ImgMap[featIdx];

    set<FeatureId>::iterator itr1 = imgMap.begin();
    for(; itr1 != imgMap.end(); itr1++) {
      featHist[(*itr1)] += (1.0f*weight);
    }
  }

  for(int i=0; i < featHist.size(); i++) {
    featHist[i] /= featIndices.size();
  }
}  


bool EvaluateContextScores(vector< ViewInfoWithPoints>& views, vector< TwoViewInfoWithPoints >& twoViewInfoVec) {
  for(int i=0; i < twoViewInfoVec.size(); i++) {

    TwoViewInfoWithPoints& pairwise = twoViewInfoVec[i];
    int img1 = pairwise.image1;
    int img2 = pairwise.image2;

    int degree1 = views[img1].degree;
    int degree2 = views[img2].degree;

    set<FeatureId>& s1 = views[img1].matchedFeatureIndices;
    set<FeatureId>& s2 = views[img2].matchedFeatureIndices;

    set<FeatureId>& d1 = pairwise.matchedFeatureIndices1;
    set<FeatureId>& d2 = pairwise.matchedFeatureIndices2;
  
    set<int> u1, u2;
    set_difference(s1.begin(), s1.end(), d1.begin(), d1.end(), inserter(u1, u1.end())); 
    set_difference(s2.begin(), s2.end(), d2.begin(), d2.end(), inserter(u2, u2.end())); 
 
      vector< float > identityWeights1(u1.size(), 1.0f);
      vector< float > identityWeights2(u2.size(), 1.0f);

      int numImages = views.size();

      pairwise.contextFeatureDist1.resize(numImages, 0.0f);
      pairwise.contextFeatureDist2.resize(numImages, 0.0f);

    ComputeFeatureDistribution(u1, identityWeights1, 
        views[img1].feature2ImageMap, pairwise.contextFeatureDist1); 
    ComputeFeatureDistribution(u2, identityWeights2, 
        views[img2].feature2ImageMap, pairwise.contextFeatureDist2); 

    float* ptr1 = pairwise.contextFeatureDist1.data();
    float* ptr2 = pairwise.contextFeatureDist2.data();

    Eigen::Map<Eigen::VectorXf> vec1( ptr1 , pairwise.contextFeatureDist1.size());
    Eigen::Map<Eigen::VectorXf> vec2( ptr2 , pairwise.contextFeatureDist2.size());

    double threshold1 = 10.0/u1.size();
    double threshold2 = 10.0/u2.size();

    double hammingDistance = 0.0f;
    for(int j=0; j < pairwise.contextFeatureDist1.size(); j++) {
      bool val1 = false;
      bool val2 = false;
      if(pairwise.contextFeatureDist1[j] > threshold1) {
        val1 = true;
      } 

      if(pairwise.contextFeatureDist2[j] > threshold2) {
        val2 = true;
      }

      if(val1 != val2) {
        hammingDistance = hammingDistance + 1;
      }
    }

    pairwise.contextScoreChiSqr = cv::compareHist(cv::Mat(pairwise.contextFeatureDist1), cv::Mat(pairwise.contextFeatureDist2), CV_COMP_CHISQR);
    pairwise.contextScoreCosine = vec1.dot(vec2);
    pairwise.contextScoreHamming = hammingDistance / (degree1 + degree2);

  }
}

bool ReadNormOptFile(string fileName, ScoresStruct& scoreStr) {

  ifstream inFile( fileName);
  if( !inFile.is_open() ) {
    printf("\nFile is not open");
    fflush(stdout);
  }

  string line;
  vector< vector<string> > strings;
  while ( std::getline(inFile, line)) {
    std::istringstream str ( line );
    vector<string> currLine;
    currLine.insert(currLine.end(), 
        std::istream_iterator<std::string>(str),  
        std::istream_iterator<std::string>());
  }

  for(int i=0; i < strings.size(); i++) {
    vector<string> currLine = strings[i];
    string token = currLine[0];
    if(token[0] == '#') {
      continue;
    }

    NormParams* params;
    if(token == "NODECONN") {
      params = &(scoreStr.params[NCONN]);
    } else if(token == "FEATCONN" ) {
      params = &(scoreStr.params[FCONN]);
    } else if(token == "DISJOINT") { 
      params = &(scoreStr.params[DSJT]);
    } else if(token == "OVERLAPSUM") { 
      params = &(scoreStr.params[OVSUM]);
    } else if(token == "OVERLAPMULT") {
      params = &(scoreStr.params[OVMUL]);
    } else if(token == "HOMOGRAPHY") { 
      params = &(scoreStr.params[HG]);
    } else if(token == "CTXCHISQR") { 
      params = &(scoreStr.params[CTXCHI2]); 
    } else if(token == "CTXHAMMING") {
      params = &(scoreStr.params[CTXHM]);
    } else if(token == "CTXCOSINE") { 
      params = &(scoreStr.params[CTXCS]);
    } else if(token == "TRIPLET") { 
      params = &(scoreStr.params[TRIPLET]);
    } else if( token == "MULTIMOT") {
      params = &(scoreStr.params[MMOTION]);
    } else if( token == "LOOPCONST" ) {
      params = &(scoreStr.params[LOOP]);
    }
    params->initialized = true;

    istringstream(currLine[1]) >> params->minMax01;
    istringstream(currLine[2]) >> params->k1;
    istringstream(currLine[3]) >> params->k2;
    istringstream(currLine[4]) >> params->k3;
    istringstream(currLine[5]) >> params->k4;
    istringstream(currLine[6]) >> params->k5;
    istringstream(currLine[7]) >> params->k6;
    istringstream(currLine[8]) >> params->high;
    istringstream(currLine[9]) >> params->low;
  }
}

void PopulateScoresStructure( vector<TwoViewInfoWithPoints>& twoviewInfo, 
    vector<ViewInfoWithPoints>& views, ScoresStruct& scoreStr) {

  set<int> allIndices;
  int edgeIdx = 0;
  for(int i=0; i < twoviewInfo.size(); i++) {
    TwoViewInfoWithPoints& pairwise = twoviewInfo[i];
    if(pairwise.viewGraphEdgeIntialized) {
      scoreStr.scoreIdx2Edge.insert( make_pair(edgeIdx, i) );
      edgeIdx++;

      scoreStr.inScore[OVSUM].push_back( 0.5*(pairwise.ratio1 + pairwise.ratio2) ); 
      scoreStr.inScore[OVMUL].push_back(pairwise.ratio1*pairwise.ratio2); 
      scoreStr.inScore[HG].push_back(pairwise.homographyScore);
      scoreStr.inScore[CTXCS].push_back(pairwise.contextScoreCosine);
      scoreStr.inScore[CTXHM].push_back(pairwise.contextScoreHamming);
      scoreStr.inScore[CTXCHI2].push_back(pairwise.contextScoreChiSqr);
      //scoreStr.inScore[TRIPLET].push_back();
      //scoreStr.inScore[MMOTION].push_back(pairwise.twoGeomScore);
      //scoreStr.inScore[LOOP].push_back( );
      //
      allIndices.insert(pairwise.image1);
      allIndices.insert(pairwise.image2);

      if(allIndices.size() != views.size()) {
        printf("\nSome images not part of edges ... big problem.. exiting");
        exit(-1);
      }
    } 
  }

  for(int i=0; i < views.size(); i++) {
    scoreStr.scoreIdx2Node.insert(make_pair(i,i));
    scoreStr.inScore[NCONN].push_back(views[i].connectivityFitness);
    scoreStr.inScore[FCONN].push_back(views[i].featureFitness);
    scoreStr.inScore[DSJT].push_back(views[i].disjointFitness);
  }

  scoreStr.normalizeAllScores();
}

int main(int argc, char* argv[]) {
  google::InitGoogleLogging(argv[0]);

  string baseDirectory = string(argv[1]);
  string matchesFile = baseDirectory + "/matches.txt";
  string imgListFile = baseDirectory + "/list_images.txt";
  string keyListFile = baseDirectory + "/list_keys.txt";
  string normOptFile = baseDirectory + "/norm_options.txt";

  int totalFlow = atoi(argv[2]);

  ScoresStruct scoreStr;
  bool s0 = ReadNormOptFile( normOptFile , scoreStr); 
 
 


  // Read image file names and dimensions
  reader::ImageListReader imgList(baseDirectory);
  bool s1 = imgList.read();

  // Read keyfile names
  reader::KeyListReader keyList(baseDirectory);
  bool s2 = keyList.read();

  // Check if list files are read correctly
  if(!s1 || !s2) {
    printf("\nError reading list file or key file");
    return 0;
  }

  unsigned int numImages = imgList.getNumImages();
  unsigned int numKeys = keyList.getNumKeys();

  printf("\nNumber of images %d", numImages);
  printf("\nNumber of keys %d", numKeys);

  theia::ExifReader exReader;
  vector< ViewInfoWithPoints > views( numImages );
  vector< theia::View > base_views( numImages );

  for(int i=0; i < numImages; i++) {
    // Get image name (abc.jpg) if full path is given
    string path = imgList.getImageName(i);
    size_t sep = path.find_last_of("\\/");
    if (sep != std::string::npos)
      path = path.substr(sep + 1, path.size() - sep - 1);
    base_views[i] = theia::View( path );

    views[i].degree = 0;
    views[i].readImageInfo( imgList.getImageName(i) , exReader);
    views[i].readKeys( keyList.getKeyName(i) , true);

    theia::CameraIntrinsicsPrior* prior = base_views[i].MutableCameraIntrinsicsPrior();
    (*prior) = views[i].CameraIntrinsicsPrior();
  }

  vector< TwoViewInfoWithPoints > twoViewInfoVec;
  std::unordered_map<theia::ViewIdPair, int> edge2indexMap;
  bool s3 = ReadBundlerMatchGraph( matchesFile, views, twoViewInfoVec, edge2indexMap);
  printf("\nDone reading bundler files");
  fflush(stdout);
  
  theia::ViewGraph viewingGraph;
  bool s4 = EstimateViewingGraph( views, twoViewInfoVec, &viewingGraph );
  printf("\nDone estimating view-graph geometry");
  fflush(stdout);

//  EstimateSecondaryGeometry(views, twoViewInfoVec);
//  printf("\nDone estimating secondary geometry");
//  fflush(stdout);

  EvaluateTripletsForRotationLoop(&viewingGraph, edge2indexMap, twoViewInfoVec);
  printf("\nDone estimating triplet loops");
  fflush(stdout);

  EvaluateContextScores(views, twoViewInfoVec);
  printf("\nDone estimating context scores");
  fflush(stdout);

  //EstimateConnectivityScore( twoViewInfoVec, views );
  printf("\nDone estimating connectivity scores");
  fflush(stdout);


  PopulateScoresStructure( twoViewInfoVec, views , scoreStr);

  vector<double> nodeCosts;
  vector<double> edgeCosts;
  CreateCostsFromScores( scoreStr, nodeCosts, edgeCosts);

  exit(-1);


  ViewGraphFilter filter;
  filter.pairsInfoPtr = &(twoViewInfoVec);
  filter.viewsPtr = &(views);
  filter.edge2indexMap = &(edge2indexMap);

  filter.constructNetworkFlowProblem(totalFlow);
  filter.solveNetworkFlowProblem();


  const auto& all_edges = viewingGraph.GetAllEdges();
  theia::ReconstructionBuilderOptions options;
  options.reconstruction_estimator_options.reconstruction_estimator_type = 
    theia::ReconstructionEstimatorType::INCREMENTAL;

  theia::ReconstructionBuilder reconstruction_builder(options);

  for(int i=0; i < base_views.size(); i++) {
    reconstruction_builder.AddImageWithCameraIntrinsicsPrior(
        base_views[i].Name(), views[i].CameraIntrinsicsPrior(), 
        theia::kInvalidCameraIntrinsicsGroupId);
  }

  printf("\nAdded all images");
  fflush(stdout);

  // Create an MST reconstruction.
  for (int i=0; i < filter.selectedEdges.size(); i++) {
    int pairIndex = optEdge2pairwiseIdx[filter.selectedEdges[i]];

    TwoViewInfoWithPoints pairwise = twoViewInfoVec[pairIndex];
    //DrawPairsWithPoints(views[pairwise.image1].fullImageName, views[pairwise.image2].fullImageName, pairwise.verifiedFeatures1, pairwise.verifiedFeatures2, jointScore[pairIndex], outputFile.str());

    theia::ImagePairMatch imgPair;
    imgPair.image1 = base_views[pairwise.image1].Name();
    imgPair.image2 = base_views[pairwise.image2].Name();

    imgPair.twoview_info = pairwise;
    imgPair.correspondences.resize( pairwise.verifiedFeatures1.size() );

    for(int i=0; i < imgPair.correspondences.size(); i++) {
      imgPair.correspondences[i].feature1 = theia::Feature(pairwise.verifiedFeatures1[i].x, pairwise.verifiedFeatures1[i].y);
      imgPair.correspondences[i].feature2 = theia::Feature(pairwise.verifiedFeatures2[i].x, pairwise.verifiedFeatures2[i].y);
    }

    reconstruction_builder.AddTwoViewMatch( base_views[pairwise.image1].Name(), base_views[pairwise.image2].Name(), imgPair );

  }
  printf("\nAdded all pairs");
  fflush(stdout);


  std::vector<theia::Reconstruction*> reconstructions;
  bool status = reconstruction_builder.BuildReconstruction(&reconstructions);

  if(!status) {
    cout << "\nFailed to create reconstruction";
    fflush(stdout);
    exit(-1);

  }

  string output_prefix = "result_reconstruction";
  for (int i = 0; i < reconstructions.size(); i++) {
    const std::string output_file =
      theia::StringPrintf("%s-%d", output_prefix.c_str(), i);
    cout << "Writing reconstruction " << i << " to " << output_file;
    if(!theia::WriteReconstruction(*reconstructions[i], output_file))
      cout << "Could not write reconstruction to file.";
  }

  fflush(stdout);

  return 0;
}
